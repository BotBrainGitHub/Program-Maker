'%%section:Preamble
' {$STAMP BS2}
' {$PBASIC 2.5}

'Scribbler include code version 2007.07.25
'%%heading:Pin Definitions
LEDLeft      PIN 0
LWhisker     PIN 1
RWhisker       PIN 2
LightLeft      PIN 3
ObsTxLeft       PIN 4
ObsTxRight        PIN 5
ObsRx           PIN 6
LEDRight           PIN 7
LightCenter        PIN 8
LIghtRight       PIN 9
Servo2         PIN 10
Servo3         PIN 11
MotorRight      PIN 12
MotorLeft       PIN 13
TripDrain      PIN 14
Speaker       PIN 15
'%%heading:Pin Initializations
OUTS = %0000000000000111
DIRS = %1111111100000000
'%%heading:Global Variables
Readout VAR Word  'for debugging purposes
ScrW0           VAR W0
ScrW1           VAR W1

ScrB0           VAR ScrW0.LOWBYTE
ScrB1           VAR ScrW0.HIGHBYTE
ScrB2           VAR ScrW1.LOWBYTE
ScrB3           VAR ScrW1.HIGHBYTE

ScrN0           VAR ScrB0.LOWNIB
ScrN1           VAR ScrB0.HIGHNIB
ScrN2           VAR ScrB1.LOWNIB
ScrN3           VAR ScrB1.HIGHNIB

ScrT0           VAR ScrB3.BIT0
ScrT1           VAR ScrB3.BIT1
ScrT2           VAR ScrB3.BIT2
ScrT3           VAR ScrB3.BIT3
ScrT4           VAR ScrB3.BIT4
ScrT5           VAR ScrB3.BIT5
ScrT6           VAR ScrB3.BIT6
ScrT7           VAR ScrB3.BIT7

Moves           VAR ScrB0

MoveRight       VAR ScrB0
MoveLeft        VAR ScrB1
MoveTime        VAR ScrB2

CoinFlip        VAR W2

Lights          VAR B6

RightLight      VAR B6
CenterLight     VAR B7
LeftLight       VAR B8

RefLights       VAR B9

RefRightLight   VAR B9
RefCenterLight  VAR B10
RefLeftLight    VAR B11

Counter0        VAR B12
Counter1        VAR B13
Counter2        VAR B14
Counter3        VAR B15
Counter4        VAR B16
Counter5        VAR B17

ResetCount      VAR B18.NIB0  'Was ScrN0. Changed for persistence.

Reserved0       VAR B18.NIB1
Reserved1       VAR B19
Reserved2       VAR B20

Motors          VAR B21

RightMotor      VAR B21    'byte
LeftMotor       VAR B22    'byte

LineCount       VAR B23.HIGHNIB
ObstacleCount   VAR B23.LOWNIB
StallCount      VAR B24.HIGHNIB

LeftLine        VAR B24.BIT3
RightLine       VAR B24.BIT2

LeftObstacle    VAR B24.BIT1
RightObstacle   VAR B24.BIT0

Flags           VAR B25

Flag_green      VAR Flags.BIT7
Flag_yellow     VAR Flags.BIT6
Flag_orange     VAR Flags.BIT5
Flag_red        VAR Flags.BIT4
Flag_magenta    VAR Flags.BIT3
Flag_purple     VAR Flags.BIT2
Flag_blue       VAR Flags.BIT1
Stalled         VAR Flags.BIT0
'%%heading:Protect Calibration Data in EEPROM
DATA @0, (16)
'%%heading:Count Reset Button Presses
READ 15, ResetCount
WRITE 15, ResetCount + 1 MAX 15
PAUSE 500
WRITE 15, 0
'%%heading:Variable Initialization
LeftMotor = 128
RightMotor = 128
'%%heading:Check Calibration Values and Repair
'FOR ScrN1 = 0 TO 4 STEP 4
 ' ScrB1 = 0
'  FOR ScrB2 = ScrN1 TO ScrN1 + 3
'    READ ScrB2, ScrB3
'    ScrB1 = ScrB1 + ScrB3
'  NEXT
'  IF (ScrB1) THEN
'    FOR ScrB2 = ScrN1 TO ScrN1 + 3
'      WRITE ScrB2, 128 << ScrN1
'    NEXT
'  ENDIF
'NEXT
'%%heading:Initialize Random Number Generator
HIGH LightLeft
PAUSE 1
RCTIME LightLeft, 1, CoinFlip
'%%section:MotorAdd
'%%heading:Increment Motor Speeds
'%%requires:MotorSet
MotorAdd:  'Increment Speeds
  RightMotor = RightMotor + MoveRight MIN 156 MAX 356 - 128
  LeftMotor = LeftMotor + MoveLeft MIN 156 MAX 356 - 128
GOTO MotorSet
'%%section:MotorMul
'%%heading:Multiply Motor Speeds
'%%requires:MotorSet
MotorMul:
  FOR ScrB3 = 0 TO 1
    Motors(ScrB3) = (Motors(ScrB3) - 128) * (Moves(ScrB3) - 128) >> 6 + 128 & 255 MIN 28 MAX 228
  NEXT
GOTO MotorSet
'%%section:MotorSet
'%%heading:Set Motor Speeds
MotorSet:
  readout =  ((650 + ScrB3-128) - RightMotor)
  DEBUG "Right servo is getting   ", DEC readout, CR
   readout =  ((759 - 128) + LeftMotor)
  DEBUG "Left servo is getting   ", DEC readout, CR
  FOR ScrB3 = 0 TO MoveTime
  READ 2, ScrB3
  PULSOUT MotorRight, ((650 + ScrB3-128)+RightMotor) '768 is test value from GUIbot
  'PAUSE 1
  'IF (MoveTime) THEN PULSOUT MotorRight, (RightMotor + (768 -128))  '768 is test value from GUIbot
  READ 1, ScrB3
  'PULSOUT MotorLeft, (LeftMotor - 128) * ScrB3 >> 7 + 256 & 511 MIN 156 * 10 - 560
  'PAUSE 1
  'IF (MoveTime) THEN PULSOUT MotorLeft, (LeftMotor + (759 - 128))  '759 is test value from GUIbot
    PULSOUT MotorLeft, ((650 + ScrB3) - LeftMotor)  '759 is test value from GUIbot
  PAUSE 5
  NEXT
RETURN
'%%section:RefLightLight
'%%heading:Transfer Current Light Readings to Reference Readings
RefLightLight:
  FOR ScrB0 = 0 TO 2
    RefLights(ScrB0) = Lights(ScrB0)
  NEXT
RETURN
'%%section:RefLightZero
'%%heading:Zero the Reference Light Readings
RefLightZero:
  FOR ScrB0 = 0 TO 2
    RefLights(ScrB0) = 0
  NEXT
RETURN
'%%section:RefLightRom
'%%heading:Read the Reference Light Readings from ROM
RefLightRom:
  FOR ScrB0 = 0 TO 2
    READ ScrB0 + 4, RefLights(ScrB0)
  NEXT
RETURN
'%%section:ComputePosDif
'%%heading:Compute the Difference Between Current Light Readings and Reference Readings
ComputePosDif:
  FOR ScrB0 = 0 TO 2
    Lights(ScrB0) = Lights(ScrB0) -  RefLights(ScrB0) + 256 MIN 256 - 256
  NEXT
RETURN
'%%section:ComputeNegDif
'%%heading:Compute the Difference Between Reference Readings and Current Light Readings
ComputeNegDif:
  FOR ScrB0 = 0 TO 2
    Lights(ScrB0) = RefLights(ScrB0) -  Lights(ScrB0) + 256 MIN 256 - 256
  NEXT
RETURN
'%%section:ComputeAbsDif
'%%heading:Compute the Absolute Difference Between Current Light Readings and Reference Readings
ComputeAbsDif:
  FOR ScrB0 = 0 TO 2
    Lights(ScrB0) = ABS(RefLights(ScrB0) -  Lights(ScrB0))
  NEXT
RETURN
'%%section:ReadLight
'%%heading:Read Light Sensors
ReadLight:
  HIGH LightLeft
  HIGH LightCenter
  HIGH LightRight
  PAUSE 3
  FOR ScrB2 = 0 TO 2
    RCTIME LightRight + ScrB2, 1, ScrW0
    IF (ScrW0 = 0) THEN ScrW0 = 65535
    ScrB3 = NCD ScrW0 - 1
    ScrW0 = ScrW0 << (15 - ScrB3)
    LOOKDOWN ScrW0.HIGHBYTE, <=[133, 139, 145, 152, 158, 165, 173, 181, 189, 197, 206, 215, 224, 234, 245, 255], ScrW0
    Lights(ScrB2) = ~(ScrB3 << 4 + ScrW0)
  NEXT
RETURN
'%%section:ReadBars
'%%heading:Read Bar Codes
ReadBars:
  HIGH LineEnable
  PAUSE 1
  IF (LineLeft = 0 OR LineRight = 0) THEN NoBars
  DO WHILE (LineRight)
  LOOP
  PULSIN LineRight, 1, ScrW1
  IF (ScrW1 = 0) THEN NoBars
  PULSIN LineRight, 1, ScrW0
  IF (ScrW0 = 0) THEN NoBars
  ScrB3 = (ScrW0 >> 1) + (ScrW1 >> 1) >> 8
  FOR ScrB2 = 1 TO 5
    IF (ScrB2 <= 4) THEN
      LineCount = LineCount << 1
      IF (ScrW0.HIGHBYTE > ScrB3) THEN LineCount.LOWBIT = 1
    ENDIF
    PULSIN LineRight, 1, ScrW0
    IF (ScrW0 = 0) THEN NoBars
  NEXT
  IF (LineCount.BIT3) THEN LineCount = LineCount REV 3 | 8
  GOTO LineDisable
NoBars:
  Linecount = 0
LineDisable:
  LOW LineEnable
RETURN
'%%section:ReadLine
'%%heading:Read the Line Sensors
ReadLine:
  HIGH LineEnable
  PAUSE 1
  ScrT0 = LineLeft
  ScrT1 = LineRight
  IF (ScrT0 = LeftLine AND ScrT1 = RightLine) THEN
    LineCount = LineCount + 1 MAX 8
  ELSE
    LineCount = 1
    LeftLine = ScrT0
    RightLine = ScrT1
  ENDIF
  LOW LineEnable
RETURN
'%%section:ReadObstacle
'%%heading:Read Obstacle Sensors
ReadObstacle:
  FREQOUT ObsTxLeft, 1, 40500
  ScrT0 = ~ ObsRx
  LOW ObsTxLeft
  FREQOUT ObsTxRight, 1, 40500
  ScrT1 = ~ ObsRx
  LOW ObsTxRight
  IF (ScrT0 = LeftObstacle AND ScrT1 = RightObstacle) THEN
    ObstacleCount = ObstacleCount + 1 MAX 8
  ELSE
    ObstacleCount = 1
    LeftObstacle = ScrT0
    RightObstacle = ScrT1
  ENDIF
RETURN
'%%section:ReadStall
'%%heading:Read Stall Sensor
ReadStall:
  Stalled = Stall
  IF (Stalled) THEN
    StallCount = StallCount + 1 MAX 8
  ELSE
    StallCount = 0
  ENDIF
RETURN
'%%section:FlipCoin
'%%heading:Flip a Coin
FlipCoin:
  RANDOM CoinFlip
RETURN
'%%section:Postscript
'%%heading:End of Program